//
//  SentryService.swift
//  Tenney
//
//  Created by Autogenerated on 2025-01-01.
//

import Foundation
import Sentry

@MainActor
final class SentryService {
    static let shared = SentryService()

    private var enabled = false

    private init() { }

    func setEnabled(_ on: Bool) {
        guard on else {
            SentrySDK.flush(timeout: 2.0)
            SentrySDK.close()
            enabled = false
            return
        }

        guard !enabled else { return }

        guard let dsn = Bundle.main.object(forInfoDictionaryKey: "SentryDSN") as? String else {
            return
        }

        let trimmed = dsn.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return }

        // If Info.plist substitution didn’t occur, you’ll get a literal "$(SENTRY_DSN)".
        // Don’t start Sentry in that case.
        guard !trimmed.contains("$(") else { return }

        // Basic sanity so we don’t “start” with garbage in production.
        guard trimmed.hasPrefix("http"), trimmed.contains("@") else { return }

        SentrySDK.start { options in
            options.dsn = trimmed
            options.sendDefaultPii = false
            options.tracesSampleRate = 0
            options.enableAppHangTracking = false
            options.enableNetworkTracking = false
            options.enableSwizzling = false

            #if DEBUG
            options.environment = "debug"
            #else
            options.environment = "release"
            #endif
        }


        enabled = true
    }

    func breadcrumb(category: String, message: String, level: SentryLevel = .info) {
        guard enabled else { return }
        let crumb = Breadcrumb()
        crumb.category = category
        crumb.message = message
        crumb.level = level
        SentrySDK.addBreadcrumb(crumb)
    }

    func captureNonFatal(_ error: Error, context: [String: Any]? = nil) {
        guard enabled else { return }
        let event = Event()
        event.level = .error
        event.message = SentryMessage(formatted: String(describing: error))
        var extras = context ?? [:]
        let logs = DiagnosticsCenter.shared.recentLogLines(limit: 80).joined(separator: "\n")
        if !logs.isEmpty {
            extras["logs"] = logs
        }
        if !extras.isEmpty {
            event.extra = extras
        }
        SentrySDK.capture(event: event)
    }

    func sendDebugBundleToSentry(zipURL: URL, summaryJSON: String) async {
        guard enabled else { return }

        let hadPreviousCrash = UserDefaults.standard.double(forKey: SettingsKeys.lastSessionCrashTimestamp) > 0

        await Task.detached(priority: .utility) {
            let event = Event()
            event.level = .info
            event.message = SentryMessage(formatted: "User shared debug bundle")
            event.extra = [
                "source": "settings",
                "hadPreviousCrashMarker": hadPreviousCrash
            ]

            SentrySDK.configureScope { scope in
                scope.addAttachment(
                    Attachment(
                        path: zipURL.path,
                        filename: zipURL.lastPathComponent,
                        contentType: "application/zip"
                    )
                )
                scope.addAttachment(
                    Attachment(
                        data: Data(summaryJSON.utf8),
                        filename: "clipboard-summary.json",
                        contentType: "application/json"
                    )
                )
            }

            SentrySDK.capture(event: event)
            SentrySDK.flush(timeout: 2.0)
            SentrySDK.configureScope { scope in
                scope.clearAttachments()
            }
        }.value
    }
}
