//
//  DiagnosticsCenter.swift
//  Tenney
//
//  Created by Autogenerated on 2025-01-01.
//

import Foundation
import ZIPFoundation

enum DiagnosticLevel: String, Codable {
    case info
    case warning
    case error
}

struct DiagnosticEvent: Codable {
    let timestamp: Date
    let category: String
    let level: DiagnosticLevel
    let message: String
    let meta: [String: String]?
}

struct TunerSnapshot: Codable {
    let timestamp: Date
    let cents: Double
    let confidence: Double
    let mode: String
    let viewStyle: String
    let locked: Bool
    let target: String?
}

final class DiagnosticsCenter {
    static let shared = DiagnosticsCenter()

    private let queue = DispatchQueue(label: "com.tenney.diagnostics", qos: .utility)
    private let window: TimeInterval = 600 // 10 minutes
    private let maxEvents = 800
    private let maxSnapshots = 800

    private var events: [DiagnosticEvent] = []
    private var tunerSnapshots: [TunerSnapshot] = []

    private init() { }

    func log(_ message: String, level: DiagnosticLevel = .info, category: String = "log", meta: [String: String]? = nil) {
        event(category: category, level: level, message: message, meta: meta)
    }

    func event(category: String, level: DiagnosticLevel = .info, message: String, meta: [String: String]? = nil) {
        let sanitizedMessage = sanitize(message)
        let sanitizedMeta = meta?.mapValues { sanitize($0) }
        let event = DiagnosticEvent(
            timestamp: Date(),
            category: category,
            level: level,
            message: sanitizedMessage,
            meta: sanitizedMeta
        )
        enqueueEvent(event)
    }

    func recordTunerSnapshot(cents: Double, confidence: Double, mode: String, viewStyle: String, locked: Bool, target: String?) {
        let snap = TunerSnapshot(
            timestamp: Date(),
            cents: cents,
            confidence: confidence,
            mode: sanitize(mode),
            viewStyle: sanitize(viewStyle),
            locked: locked,
            target: target.map { sanitize($0) }
        )
        enqueueSnapshot(snap)
    }

    func exportClipboardSummary() async -> String {
        let snapshot = currentSnapshot()
        var payload: [String: Any] = [
            "app": [
                "version": AboutAppInfo.version,
                "build": AboutAppInfo.build,
                "platform": currentPlatform()
            ],
            "recentEvents": snapshot.events.suffix(12).map(eventDict(_:))
        ]

        let crashTs = UserDefaults.standard.double(forKey: SettingsKeys.lastSessionCrashTimestamp)
        if crashTs > 0 {
            payload["lastCrash"] = [
                "timestamp": ISO8601DateFormatter().string(from: Date(timeIntervalSince1970: crashTs)),
                "reason": "marker"
            ]
        }

        guard let data = try? JSONSerialization.data(withJSONObject: payload, options: [.sortedKeys]) else {
            return "{}"
        }
        return String(data: data, encoding: .utf8) ?? "{}"
    }

    func exportDebugBundle() async throws -> URL {
        let snapshot = currentSnapshot()
        return try await Task.detached(priority: .utility) {
            let fm = FileManager.default

            let bundleName = "Tenney-DebugBundle-\(AboutAppInfo.version)-\(Int(Date().timeIntervalSince1970)).zip"
            let folder = fm.temporaryDirectory.appendingPathComponent(UUID().uuidString, isDirectory: true)
            try fm.createDirectory(at: folder, withIntermediateDirectories: true)

            let diagnosticsURL = folder.appendingPathComponent("diagnostics.json")
            let logsURL = folder.appendingPathComponent("logs.txt")
            let crashURL = folder.appendingPathComponent("crash.json")

            let diagPayload: [String: Any] = [
                "app": [
                    "version": AboutAppInfo.version,
                    "build": AboutAppInfo.build,
                    "platform": currentPlatform()
                ],
                "events": snapshot.events.map(eventDict(_:)),
                "tuner": snapshot.tunerSnapshots.map { snap in
                    [
                        "timestamp": isoTimestamp(snap.timestamp),
                        "cents": snap.cents,
                        "confidence": snap.confidence,
                        "mode": snap.mode,
                        "viewStyle": snap.viewStyle,
                        "locked": snap.locked,
                        "target": snap.target as Any
                    ]
                }
            ]

            if let data = try? JSONSerialization.data(withJSONObject: diagPayload, options: [.prettyPrinted, .sortedKeys]) {
                try data.write(to: diagnosticsURL, options: [.atomic])
            }

            let logText = snapshot.events
                .map { "[\(isoTimestamp($0.timestamp))] [\($0.category)] [\($0.level.rawValue)] \($0.message)" }
                .joined(separator: "\n")
            try logText.data(using: .utf8)?.write(to: logsURL, options: [.atomic])

            let crashTs = UserDefaults.standard.double(forKey: SettingsKeys.lastSessionCrashTimestamp)
            if crashTs > 0 {
                let crashPayload: [String: Any] = [
                    "timestamp": isoTimestamp(Date(timeIntervalSince1970: crashTs)),
                    "reason": "marker"
                ]
                if let data = try? JSONSerialization.data(withJSONObject: crashPayload, options: [.prettyPrinted, .sortedKeys]) {
                    try data.write(to: crashURL, options: [.atomic])
                }
            }

            let zipURL = fm.temporaryDirectory.appendingPathComponent(bundleName)
            if fm.fileExists(atPath: zipURL.path) {
                try? fm.removeItem(at: zipURL)
            }
            try fm.zipItem(at: folder, to: zipURL)
            return zipURL
        }.value
    }

    func recentLogLines(limit: Int = 80) -> [String] {
        currentSnapshot().events.suffix(limit).map {
            "[\($0.category)] \($0.message)"
        }
    }

    private func enqueueEvent(_ event: DiagnosticEvent) {
        queue.async { [weak self] in
            guard let self else { return }
            events.append(event)
            trimEvents()
        }
    }

    private func enqueueSnapshot(_ snapshot: TunerSnapshot) {
        queue.async { [weak self] in
            guard let self else { return }
            tunerSnapshots.append(snapshot)
            trimSnapshots()
        }
    }

    private func trimEvents() {
        let cutoff = Date().addingTimeInterval(-window)
        events = events.filter { $0.timestamp >= cutoff }
        if events.count > maxEvents { events.removeFirst(events.count - maxEvents) }
    }

    private func trimSnapshots() {
        let cutoff = Date().addingTimeInterval(-window)
        tunerSnapshots = tunerSnapshots.filter { $0.timestamp >= cutoff }
        if tunerSnapshots.count > maxSnapshots { tunerSnapshots.removeFirst(tunerSnapshots.count - maxSnapshots) }
    }

    private func currentSnapshot() -> (events: [DiagnosticEvent], tunerSnapshots: [TunerSnapshot]) {
        var capturedEvents: [DiagnosticEvent] = []
        var capturedSnapshots: [TunerSnapshot] = []
        queue.sync {
            capturedEvents = events
            capturedSnapshots = tunerSnapshots
        }
        return (capturedEvents, capturedSnapshots)
    }

    private func sanitize(_ text: String) -> String {
        var output = text

        // Emails
        if let regex = try? NSRegularExpression(pattern: "[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}", options: [.caseInsensitive]) {
            output = regex.stringByReplacingMatches(in: output, options: [], range: NSRange(location: 0, length: output.utf16.count), withTemplate: "[redacted-email]")
        }

        // URLs – drop query/fragment
        if let detector = try? NSDataDetector(types: NSTextCheckingResult.CheckingType.link.rawValue) {
            let matches = detector.matches(in: output, options: [], range: NSRange(location: 0, length: output.utf16.count))
            for match in matches.reversed() {
                guard let range = Range(match.range, in: output), let url = URL(string: String(output[range])) else { continue }
                var comps = URLComponents(url: url, resolvingAgainstBaseURL: false)
                comps?.query = nil
                comps?.fragment = nil
                let safe = comps?.url?.absoluteString ?? "[redacted-url]"
                output.replaceSubrange(range, with: safe)
            }
        }

        // File paths
        if let pathRegex = try? NSRegularExpression(pattern: "(/[^\\s]+)+", options: []) {
            output = pathRegex.stringByReplacingMatches(in: output, options: [], range: NSRange(location: 0, length: output.utf16.count), withTemplate: "[redacted-path]")
        }

        // Bluetooth / device names – coarse redaction
        if let deviceRegex = try? NSRegularExpression(pattern: "(AirPods|Bluetooth|Speaker|Headphones)[^\\s]*", options: [.caseInsensitive]) {
            output = deviceRegex.stringByReplacingMatches(in: output, options: [], range: NSRange(location: 0, length: output.utf16.count), withTemplate: "[redacted-device]")
        }

        return output
    }

    nonisolated private func currentPlatform() -> String {
        #if os(macOS)
        return "macOS"
        #elseif targetEnvironment(macCatalyst)
        return "Mac Catalyst"
        #else
        return "iOS"
        #endif
    }

    nonisolated private func isoTimestamp(_ date: Date) -> String {
        ISO8601DateFormatter().string(from: date)
    }

    nonisolated private func eventDict(_ e: DiagnosticEvent) -> [String: Any] {
        var dict: [String: Any] = [
            "timestamp": isoTimestamp(e.timestamp),
            "category": e.category,
            "level": e.level.rawValue,
            "message": e.message
        ]
        if let meta = e.meta { dict["meta"] = meta }
        return dict
    }
}
